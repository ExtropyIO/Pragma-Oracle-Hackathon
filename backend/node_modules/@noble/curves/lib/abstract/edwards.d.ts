/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
import * as mod from './modular.js';
import * as ut from './utils.js';
import { Hex, PrivKey } from './utils.js';
import { Group, GroupConstructor } from './group.js';
import { htfOpts } from './hash-to-curve.js';
export declare type CurveType = ut.BasicCurve<bigint> & {
    a: bigint;
    d: bigint;
    hash: ut.CHash;
    randomBytes: (bytesLength?: number) => Uint8Array;
    adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;
    domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;
    uvRatio?: (u: bigint, v: bigint) => {
        isValid: boolean;
        value: bigint;
    };
    preHash?: ut.CHash;
    htfDefaults?: htfOpts;
    mapToCurve?: (scalar: bigint[]) => {
        x: bigint;
        y: bigint;
    };
};
declare function validateOpts(curve: CurveType): Readonly<{
    readonly nBitLength: number;
    readonly nByteLength: number;
    readonly Fp: mod.Field<bigint>;
    readonly n: bigint;
    readonly h: bigint;
    readonly hEff?: bigint | undefined;
    readonly Gx: bigint;
    readonly Gy: bigint;
    readonly wrapPrivateKey?: boolean | undefined;
    readonly allowInfinityPoint?: boolean | undefined;
    readonly a: bigint;
    readonly d: bigint;
    readonly hash: ut.CHash;
    readonly randomBytes: (bytesLength?: number | undefined) => Uint8Array;
    readonly adjustScalarBytes?: ((bytes: Uint8Array) => Uint8Array) | undefined;
    readonly domain?: ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array) | undefined;
    readonly uvRatio?: ((u: bigint, v: bigint) => {
        isValid: boolean;
        value: bigint;
    }) | undefined;
    readonly preHash?: ut.CHash | undefined;
    readonly htfDefaults?: htfOpts | undefined;
    readonly mapToCurve?: ((scalar: bigint[]) => {
        x: bigint;
        y: bigint;
    }) | undefined;
}>;
export interface SignatureType {
    readonly r: PointType;
    readonly s: bigint;
    assertValidity(): SignatureType;
    toRawBytes(): Uint8Array;
    toHex(): string;
}
export declare type SignatureConstructor = {
    new (r: PointType, s: bigint): SignatureType;
    fromHex(hex: Hex): SignatureType;
};
export interface ExtendedPointType extends Group<ExtendedPointType> {
    readonly x: bigint;
    readonly y: bigint;
    readonly z: bigint;
    readonly t: bigint;
    multiply(scalar: number | bigint, affinePoint?: PointType): ExtendedPointType;
    multiplyUnsafe(scalar: number | bigint): ExtendedPointType;
    isSmallOrder(): boolean;
    isTorsionFree(): boolean;
    toAffine(invZ?: bigint): PointType;
    clearCofactor(): ExtendedPointType;
}
export interface ExtendedPointConstructor extends GroupConstructor<ExtendedPointType> {
    new (x: bigint, y: bigint, z: bigint, t: bigint): ExtendedPointType;
    fromAffine(p: PointType): ExtendedPointType;
    toAffineBatch(points: ExtendedPointType[]): PointType[];
    normalizeZ(points: ExtendedPointType[]): ExtendedPointType[];
}
export interface PointType extends Group<PointType> {
    readonly x: bigint;
    readonly y: bigint;
    _setWindowSize(windowSize: number): void;
    toRawBytes(isCompressed?: boolean): Uint8Array;
    toHex(isCompressed?: boolean): string;
    isTorsionFree(): boolean;
    clearCofactor(): PointType;
}
export interface PointConstructor extends GroupConstructor<PointType> {
    new (x: bigint, y: bigint): PointType;
    fromHex(hex: Hex): PointType;
    fromPrivateKey(privateKey: PrivKey): PointType;
    hashToCurve(msg: Hex, options?: Partial<htfOpts>): PointType;
    encodeToCurve(msg: Hex, options?: Partial<htfOpts>): PointType;
}
export declare type PubKey = Hex | PointType;
export declare type SigType = Hex | SignatureType;
export declare type CurveFn = {
    CURVE: ReturnType<typeof validateOpts>;
    getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;
    sign: (message: Hex, privateKey: Hex) => Uint8Array;
    verify: (sig: SigType, message: Hex, publicKey: PubKey) => boolean;
    Point: PointConstructor;
    ExtendedPoint: ExtendedPointConstructor;
    Signature: SignatureConstructor;
    utils: {
        randomPrivateKey: () => Uint8Array;
        getExtendedPublicKey: (key: PrivKey) => {
            head: Uint8Array;
            prefix: Uint8Array;
            scalar: bigint;
            point: PointType;
            pointBytes: Uint8Array;
        };
    };
};
export declare function twistedEdwards(curveDef: CurveType): CurveFn;
export {};
