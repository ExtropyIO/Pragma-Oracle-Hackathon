/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
/**
 * BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.
 * Implements BLS (Boneh-Lynn-Shacham) signatures.
 * Consists of two curves: G1 and G2:
 * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.
 * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1
 * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in
 *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.
 * Pairing is used to aggregate and verify signatures.
 * We are using Fp for private keys (shorter) and Fp₂ for signatures (longer).
 * Some projects may prefer to swap this relation, it is not supported for now.
 */
import * as mod from './modular.js';
import * as ut from './utils.js';
import { Hex, PrivKey } from './utils.js';
import { htfOpts, stringToBytes, hash_to_field as hashToField, expand_message_xmd as expandMessageXMD } from './hash-to-curve.js';
import { CurvePointsType, PointType, CurvePointsRes } from './weierstrass.js';
declare type Fp = bigint;
export declare type SignatureCoder<Fp2> = {
    decode(hex: Hex): PointType<Fp2>;
    encode(point: PointType<Fp2>): Uint8Array;
};
export declare type CurveType<Fp, Fp2, Fp6, Fp12> = {
    r: bigint;
    G1: Omit<CurvePointsType<Fp>, 'n'>;
    G2: Omit<CurvePointsType<Fp2>, 'n'> & {
        Signature: SignatureCoder<Fp2>;
    };
    x: bigint;
    Fp: mod.Field<Fp>;
    Fr: mod.Field<bigint>;
    Fp2: mod.Field<Fp2> & {
        reim: (num: Fp2) => {
            re: bigint;
            im: bigint;
        };
        multiplyByB: (num: Fp2) => Fp2;
        frobeniusMap(num: Fp2, power: number): Fp2;
    };
    Fp6: mod.Field<Fp6>;
    Fp12: mod.Field<Fp12> & {
        frobeniusMap(num: Fp12, power: number): Fp12;
        multiplyBy014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;
        conjugate(num: Fp12): Fp12;
        finalExponentiate(num: Fp12): Fp12;
    };
    htfDefaults: htfOpts;
    hash: ut.CHash;
    randomBytes: (bytesLength?: number) => Uint8Array;
};
export declare type CurveFn<Fp, Fp2, Fp6, Fp12> = {
    CURVE: CurveType<Fp, Fp2, Fp6, Fp12>;
    Fr: mod.Field<bigint>;
    Fp: mod.Field<Fp>;
    Fp2: mod.Field<Fp2>;
    Fp6: mod.Field<Fp6>;
    Fp12: mod.Field<Fp12>;
    G1: CurvePointsRes<Fp>;
    G2: CurvePointsRes<Fp2>;
    Signature: SignatureCoder<Fp2>;
    millerLoop: (ell: [Fp2, Fp2, Fp2][], g1: [Fp, Fp]) => Fp12;
    calcPairingPrecomputes: (x: Fp2, y: Fp2) => [Fp2, Fp2, Fp2][];
    pairing: (P: PointType<Fp>, Q: PointType<Fp2>, withFinalExponent?: boolean) => Fp12;
    getPublicKey: (privateKey: PrivKey) => Uint8Array;
    sign: {
        (message: Hex, privateKey: PrivKey): Uint8Array;
        (message: PointType<Fp2>, privateKey: PrivKey): PointType<Fp2>;
    };
    verify: (signature: Hex | PointType<Fp2>, message: Hex | PointType<Fp2>, publicKey: Hex | PointType<Fp>) => boolean;
    aggregatePublicKeys: {
        (publicKeys: Hex[]): Uint8Array;
        (publicKeys: PointType<Fp>[]): PointType<Fp>;
    };
    aggregateSignatures: {
        (signatures: Hex[]): Uint8Array;
        (signatures: PointType<Fp2>[]): PointType<Fp2>;
    };
    verifyBatch: (signature: Hex | PointType<Fp2>, messages: (Hex | PointType<Fp2>)[], publicKeys: (Hex | PointType<Fp>)[]) => boolean;
    utils: {
        stringToBytes: typeof stringToBytes;
        hashToField: typeof hashToField;
        expandMessageXMD: typeof expandMessageXMD;
        getDSTLabel: () => string;
        setDSTLabel(newLabel: string): void;
    };
};
export declare function bls<Fp2, Fp6, Fp12>(CURVE: CurveType<Fp, Fp2, Fp6, Fp12>): CurveFn<Fp, Fp2, Fp6, Fp12>;
export {};
