/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
import * as mod from './modular.js';
import * as ut from './utils.js';
import { Hex, PrivKey } from './utils.js';
import { htfOpts } from './hash-to-curve.js';
import { Group, GroupConstructor } from './group.js';
declare type HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;
declare type EndomorphismOpts = {
    beta: bigint;
    splitScalar: (k: bigint) => {
        k1neg: boolean;
        k1: bigint;
        k2neg: boolean;
        k2: bigint;
    };
};
export declare type BasicCurve<T> = ut.BasicCurve<T> & {
    a: T;
    b: T;
    normalizePrivateKey?: (key: PrivKey) => PrivKey;
    wrapPrivateKey?: boolean;
    endo?: EndomorphismOpts;
    isTorsionFree?: (c: ProjectiveConstructor<T>, point: ProjectivePointType<T>) => boolean;
    clearCofactor?: (c: ProjectiveConstructor<T>, point: ProjectivePointType<T>) => ProjectivePointType<T>;
    htfDefaults?: htfOpts;
    mapToCurve?: (scalar: bigint[]) => {
        x: T;
        y: T;
    };
};
declare type Entropy = Hex | true;
export declare type SignOpts = {
    lowS?: boolean;
    extraEntropy?: Entropy;
};
/**
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 */
export interface ProjectivePointType<T> extends Group<ProjectivePointType<T>> {
    readonly x: T;
    readonly y: T;
    readonly z: T;
    multiply(scalar: number | bigint, affinePoint?: PointType<T>): ProjectivePointType<T>;
    multiplyUnsafe(scalar: bigint): ProjectivePointType<T>;
    toAffine(invZ?: T): PointType<T>;
}
export interface ProjectiveConstructor<T> extends GroupConstructor<ProjectivePointType<T>> {
    new (x: T, y: T, z: T): ProjectivePointType<T>;
    fromAffine(p: PointType<T>): ProjectivePointType<T>;
    toAffineBatch(points: ProjectivePointType<T>[]): PointType<T>[];
    normalizeZ(points: ProjectivePointType<T>[]): ProjectivePointType<T>[];
}
export interface PointType<T> extends Group<PointType<T>> {
    readonly x: T;
    readonly y: T;
    _setWindowSize(windowSize: number): void;
    hasEvenY(): boolean;
    toRawBytes(isCompressed?: boolean): Uint8Array;
    toHex(isCompressed?: boolean): string;
    assertValidity(): void;
    multiplyAndAddUnsafe(Q: PointType<T>, a: bigint, b: bigint): PointType<T> | undefined;
}
export interface PointConstructor<T> extends GroupConstructor<PointType<T>> {
    new (x: T, y: T): PointType<T>;
    fromHex(hex: Hex): PointType<T>;
    fromPrivateKey(privateKey: PrivKey): PointType<T>;
    hashToCurve(msg: Hex, options?: Partial<htfOpts>): PointType<T>;
    encodeToCurve(msg: Hex, options?: Partial<htfOpts>): PointType<T>;
}
export declare type CurvePointsType<T> = BasicCurve<T> & {
    fromBytes: (bytes: Uint8Array) => {
        x: T;
        y: T;
    };
    toBytes: (c: PointConstructor<T>, point: PointType<T>, compressed: boolean) => Uint8Array;
};
export declare type CurvePointsRes<T> = {
    Point: PointConstructor<T>;
    ProjectivePoint: ProjectiveConstructor<T>;
    normalizePrivateKey: (key: PrivKey) => bigint;
    weierstrassEquation: (x: T) => T;
    isWithinCurveOrder: (num: bigint) => boolean;
};
export declare function weierstrassPoints<T>(opts: CurvePointsType<T>): {
    Point: PointConstructor<T>;
    ProjectivePoint: ProjectiveConstructor<T>;
    normalizePrivateKey: (key: PrivKey) => bigint;
    weierstrassEquation: (x: T) => T;
    isWithinCurveOrder: (num: bigint) => boolean;
};
export interface SignatureType {
    readonly r: bigint;
    readonly s: bigint;
    readonly recovery?: number;
    assertValidity(): void;
    copyWithRecoveryBit(recovery: number): SignatureType;
    hasHighS(): boolean;
    normalizeS(): SignatureType;
    recoverPublicKey(msgHash: Hex): PointType<bigint>;
    toDERRawBytes(isCompressed?: boolean): Uint8Array;
    toDERHex(isCompressed?: boolean): string;
    toCompactRawBytes(): Uint8Array;
    toCompactHex(): string;
}
export declare type SignatureConstructor = {
    new (r: bigint, s: bigint): SignatureType;
    fromCompact(hex: Hex): SignatureType;
    fromDER(hex: Hex): SignatureType;
};
export declare type PubKey = Hex | PointType<bigint>;
export declare type CurveType = BasicCurve<bigint> & {
    lowS?: boolean;
    hash: ut.CHash;
    hmac: HmacFnSync;
    randomBytes: (bytesLength?: number) => Uint8Array;
    truncateHash?: (hash: Uint8Array, truncateOnly?: boolean) => bigint;
};
declare function validateOpts(curve: CurveType): Readonly<{
    readonly nBitLength: number;
    readonly nByteLength: number;
    readonly Fp: mod.Field<bigint>;
    readonly n: bigint;
    readonly h: bigint;
    readonly hEff?: bigint | undefined;
    readonly Gx: bigint;
    readonly Gy: bigint;
    readonly wrapPrivateKey?: boolean | undefined;
    readonly allowInfinityPoint?: boolean | undefined;
    readonly a: bigint;
    readonly b: bigint;
    readonly normalizePrivateKey?: ((key: ut.PrivKey) => ut.PrivKey) | undefined;
    readonly endo?: EndomorphismOpts | undefined;
    readonly isTorsionFree?: ((c: ProjectiveConstructor<bigint>, point: ProjectivePointType<bigint>) => boolean) | undefined;
    readonly clearCofactor?: ((c: ProjectiveConstructor<bigint>, point: ProjectivePointType<bigint>) => ProjectivePointType<bigint>) | undefined;
    readonly htfDefaults?: htfOpts | undefined;
    readonly mapToCurve?: ((scalar: bigint[]) => {
        x: bigint;
        y: bigint;
    }) | undefined;
    lowS: boolean;
    readonly hash: ut.CHash;
    readonly hmac: HmacFnSync;
    readonly randomBytes: (bytesLength?: number | undefined) => Uint8Array;
    readonly truncateHash?: ((hash: Uint8Array, truncateOnly?: boolean | undefined) => bigint) | undefined;
}>;
export declare type CurveFn = {
    CURVE: ReturnType<typeof validateOpts>;
    getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;
    getSharedSecret: (privateA: PrivKey, publicB: PubKey, isCompressed?: boolean) => Uint8Array;
    sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => SignatureType;
    signUnhashed: (msg: Uint8Array, privKey: PrivKey, opts?: SignOpts) => SignatureType;
    verify: (signature: Hex | SignatureType, msgHash: Hex, publicKey: PubKey, opts?: {
        lowS?: boolean;
    }) => boolean;
    Point: PointConstructor<bigint>;
    ProjectivePoint: ProjectiveConstructor<bigint>;
    Signature: SignatureConstructor;
    utils: {
        _bigintToBytes: (num: bigint) => Uint8Array;
        _bigintToString: (num: bigint) => string;
        _normalizePrivateKey: (key: PrivKey) => bigint;
        _normalizePublicKey: (publicKey: PubKey) => PointType<bigint>;
        _isWithinCurveOrder: (num: bigint) => boolean;
        _isValidFieldElement: (num: bigint) => boolean;
        _weierstrassEquation: (x: bigint) => bigint;
        isValidPrivateKey(privateKey: PrivKey): boolean;
        hashToPrivateKey: (hash: Hex) => Uint8Array;
        randomPrivateKey: () => Uint8Array;
    };
};
export declare function weierstrass(curveDef: CurveType): CurveFn;
export declare function SWUFpSqrtRatio<T>(Fp: mod.Field<T>, Z: T): (u: T, v: T) => {
    isValid: boolean;
    value: T;
};
export declare function mapToCurveSimpleSWU<T>(Fp: mod.Field<T>, opts: {
    A: T;
    B: T;
    Z: T;
}): (u: T) => {
    x: T;
    y: T;
};
export {};
