import { PointType } from './abstract/weierstrass.js';
import { Hex, PrivKey } from './abstract/utils.js';
export declare const secp256k1: Readonly<{
    create: (hash: import("./abstract/utils.js").CHash) => import("./abstract/weierstrass.js").CurveFn;
    CURVE: Readonly<{
        readonly nBitLength: number;
        readonly nByteLength: number;
        readonly Fp: import("./abstract/modular.js").Field<bigint>;
        readonly n: bigint;
        readonly h: bigint;
        readonly hEff?: bigint | undefined;
        readonly Gx: bigint;
        readonly Gy: bigint;
        readonly wrapPrivateKey?: boolean | undefined;
        readonly allowInfinityPoint?: boolean | undefined;
        readonly a: bigint;
        readonly b: bigint;
        readonly normalizePrivateKey?: ((key: PrivKey) => PrivKey) | undefined;
        readonly endo?: {
            beta: bigint;
            splitScalar: (k: bigint) => {
                k1neg: boolean;
                k1: bigint;
                k2neg: boolean;
                k2: bigint;
            };
        } | undefined;
        readonly isTorsionFree?: ((c: import("./abstract/weierstrass.js").ProjectiveConstructor<bigint>, point: import("./abstract/weierstrass.js").ProjectivePointType<bigint>) => boolean) | undefined;
        readonly clearCofactor?: ((c: import("./abstract/weierstrass.js").ProjectiveConstructor<bigint>, point: import("./abstract/weierstrass.js").ProjectivePointType<bigint>) => import("./abstract/weierstrass.js").ProjectivePointType<bigint>) | undefined;
        readonly htfDefaults?: import("./abstract/hash-to-curve.js").htfOpts | undefined;
        readonly mapToCurve?: ((scalar: bigint[]) => {
            x: bigint;
            y: bigint;
        }) | undefined;
        lowS: boolean;
        readonly hash: import("./abstract/utils.js").CHash;
        readonly hmac: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;
        readonly randomBytes: (bytesLength?: number | undefined) => Uint8Array;
        readonly truncateHash?: ((hash: Uint8Array, truncateOnly?: boolean | undefined) => bigint) | undefined;
    }>;
    getPublicKey: (privateKey: PrivKey, isCompressed?: boolean | undefined) => Uint8Array;
    getSharedSecret: (privateA: PrivKey, publicB: import("./abstract/weierstrass.js").PubKey, isCompressed?: boolean | undefined) => Uint8Array;
    sign: (msgHash: Hex, privKey: PrivKey, opts?: import("./abstract/weierstrass.js").SignOpts | undefined) => import("./abstract/weierstrass.js").SignatureType;
    signUnhashed: (msg: Uint8Array, privKey: PrivKey, opts?: import("./abstract/weierstrass.js").SignOpts | undefined) => import("./abstract/weierstrass.js").SignatureType;
    verify: (signature: Hex | import("./abstract/weierstrass.js").SignatureType, msgHash: Hex, publicKey: import("./abstract/weierstrass.js").PubKey, opts?: {
        lowS?: boolean | undefined;
    } | undefined) => boolean;
    Point: import("./abstract/weierstrass.js").PointConstructor<bigint>;
    ProjectivePoint: import("./abstract/weierstrass.js").ProjectiveConstructor<bigint>;
    Signature: import("./abstract/weierstrass.js").SignatureConstructor;
    utils: {
        _bigintToBytes: (num: bigint) => Uint8Array;
        _bigintToString: (num: bigint) => string;
        _normalizePrivateKey: (key: PrivKey) => bigint;
        _normalizePublicKey: (publicKey: import("./abstract/weierstrass.js").PubKey) => PointType<bigint>;
        _isWithinCurveOrder: (num: bigint) => boolean;
        _isValidFieldElement: (num: bigint) => boolean;
        _weierstrassEquation: (x: bigint) => bigint;
        isValidPrivateKey(privateKey: PrivKey): boolean;
        hashToPrivateKey: (hash: Hex) => Uint8Array;
        randomPrivateKey: () => Uint8Array;
    };
}>;
export declare function taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array;
declare class SchnorrSignature {
    readonly r: bigint;
    readonly s: bigint;
    constructor(r: bigint, s: bigint);
    static fromHex(hex: Hex): SchnorrSignature;
    assertValidity(): void;
    toHex(): string;
    toRawBytes(): Uint8Array;
}
/**
 * Synchronously creates Schnorr signature. Improved security: verifies itself before
 * producing an output.
 * @param msg message (not message hash)
 * @param privateKey private key
 * @param auxRand random bytes that would be added to k. Bad RNG won't break it.
 */
declare function schnorrSign(message: Hex, privateKey: PrivKey, auxRand?: Hex): Uint8Array;
/**
 * Verifies Schnorr signature synchronously.
 */
declare function schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean;
export declare const schnorr: {
    Signature: typeof SchnorrSignature;
    getPublicKey: (privateKey: PrivKey) => Uint8Array;
    sign: typeof schnorrSign;
    verify: typeof schnorrVerify;
};
export {};
