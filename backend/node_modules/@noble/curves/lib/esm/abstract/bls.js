import * as ut from './utils.js';
import { stringToBytes, hash_to_field as hashToField, expand_message_xmd as expandMessageXMD, } from './hash-to-curve.js';
import { weierstrassPoints } from './weierstrass.js';
export function bls(CURVE) {
    // Fields looks pretty specific for curve, so for now we need to pass them with options
    const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE;
    const BLS_X_LEN = ut.bitLen(CURVE.x);
    const groupLen = 32; // TODO: calculate; hardcoded for now
    // Pre-compute coefficients for sparse multiplication
    // Point addition and point double calculations is reused for coefficients
    function calcPairingPrecomputes(x, y) {
        // prettier-ignore
        const Qx = x, Qy = y, Qz = Fp2.ONE;
        // prettier-ignore
        let Rx = Qx, Ry = Qy, Rz = Qz;
        let ell_coeff = [];
        for (let i = BLS_X_LEN - 2; i >= 0; i--) {
            // Double
            let t0 = Fp2.square(Ry); // Ry²
            let t1 = Fp2.square(Rz); // Rz²
            let t2 = Fp2.multiplyByB(Fp2.mul(t1, 3n)); // 3 * T1 * B
            let t3 = Fp2.mul(t2, 3n); // 3 * T2
            let t4 = Fp2.sub(Fp2.sub(Fp2.square(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0
            ell_coeff.push([
                Fp2.sub(t2, t0),
                Fp2.mul(Fp2.square(Rx), 3n),
                Fp2.negate(t4), // -T4
            ]);
            Rx = Fp2.div(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), 2n); // ((T0 - T3) * Rx * Ry) / 2
            Ry = Fp2.sub(Fp2.square(Fp2.div(Fp2.add(t0, t3), 2n)), Fp2.mul(Fp2.square(t2), 3n)); // ((T0 + T3) / 2)² - 3 * T2²
            Rz = Fp2.mul(t0, t4); // T0 * T4
            if (ut.bitGet(CURVE.x, i)) {
                // Addition
                let t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz
                let t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz
                ell_coeff.push([
                    Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)),
                    Fp2.negate(t0),
                    t1, // T1
                ]);
                let t2 = Fp2.square(t1); // T1²
                let t3 = Fp2.mul(t2, t1); // T2 * T1
                let t4 = Fp2.mul(t2, Rx); // T2 * Rx
                let t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, 2n)), Fp2.mul(Fp2.square(t0), Rz)); // T3 - 2 * T4 + T0² * Rz
                Rx = Fp2.mul(t1, t5); // T1 * T5
                Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry
                Rz = Fp2.mul(Rz, t3); // Rz * T3
            }
        }
        return ell_coeff;
    }
    function millerLoop(ell, g1) {
        const { x } = CURVE;
        const Px = g1[0];
        const Py = g1[1];
        let f12 = Fp12.ONE;
        for (let j = 0, i = BLS_X_LEN - 2; i >= 0; i--, j++) {
            const E = ell[j];
            f12 = Fp12.multiplyBy014(f12, E[0], Fp2.mul(E[1], Px), Fp2.mul(E[2], Py));
            if (ut.bitGet(x, i)) {
                j += 1;
                const F = ell[j];
                f12 = Fp12.multiplyBy014(f12, F[0], Fp2.mul(F[1], Px), Fp2.mul(F[2], Py));
            }
            if (i !== 0)
                f12 = Fp12.square(f12);
        }
        return Fp12.conjugate(f12);
    }
    const utils = {
        hexToBytes: ut.hexToBytes,
        bytesToHex: ut.bytesToHex,
        stringToBytes: stringToBytes,
        // TODO: do we need to export it here?
        hashToField: (msg, count, options = {}) => hashToField(msg, count, { ...CURVE.htfDefaults, ...options }),
        expandMessageXMD: (msg, DST, lenInBytes, H = CURVE.hash) => expandMessageXMD(msg, DST, lenInBytes, H),
        hashToPrivateKey: (hash) => Fr.toBytes(ut.hashToPrivateScalar(hash, CURVE.r)),
        randomBytes: (bytesLength = groupLen) => CURVE.randomBytes(bytesLength),
        randomPrivateKey: () => utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
        getDSTLabel: () => CURVE.htfDefaults.DST,
        setDSTLabel(newLabel) {
            // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-3.1
            if (typeof newLabel !== 'string' || newLabel.length > 2048 || newLabel.length === 0) {
                throw new TypeError('Invalid DST');
            }
            CURVE.htfDefaults.DST = newLabel;
        },
    };
    // Point on G1 curve: (x, y)
    const G1 = weierstrassPoints({
        n: Fr.ORDER,
        ...CURVE.G1,
    });
    function pairingPrecomputes(point) {
        const p = point;
        if (p._PPRECOMPUTES)
            return p._PPRECOMPUTES;
        p._PPRECOMPUTES = calcPairingPrecomputes(p.x, p.y);
        return p._PPRECOMPUTES;
    }
    function clearPairingPrecomputes(point) {
        const p = point;
        p._PPRECOMPUTES = undefined;
    }
    clearPairingPrecomputes;
    function millerLoopG1(Q, P) {
        return millerLoop(pairingPrecomputes(P), [Q.x, Q.y]);
    }
    // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)
    const G2 = weierstrassPoints({
        n: Fr.ORDER,
        ...CURVE.G2,
    });
    const { Signature } = CURVE.G2;
    // Calculates bilinear pairing
    function pairing(P, Q, withFinalExponent = true) {
        if (P.equals(G1.Point.ZERO) || Q.equals(G2.Point.ZERO))
            throw new Error('No pairings at point of Infinity');
        P.assertValidity();
        Q.assertValidity();
        // Performance: 9ms for millerLoop and ~14ms for exp.
        const looped = millerLoopG1(P, Q);
        return withFinalExponent ? Fp12.finalExponentiate(looped) : looped;
    }
    function normP1(point) {
        return point instanceof G1.Point ? point : G1.Point.fromHex(point);
    }
    function normP2(point) {
        return point instanceof G2.Point ? point : Signature.decode(point);
    }
    function normP2Hash(point) {
        return point instanceof G2.Point ? point : G2.Point.hashToCurve(point);
    }
    // Multiplies generator by private key.
    // P = pk x G
    function getPublicKey(privateKey) {
        return G1.Point.fromPrivateKey(privateKey).toRawBytes(true);
    }
    function sign(message, privateKey) {
        const msgPoint = normP2Hash(message);
        msgPoint.assertValidity();
        const sigPoint = msgPoint.multiply(G1.normalizePrivateKey(privateKey));
        if (message instanceof G2.Point)
            return sigPoint;
        return Signature.encode(sigPoint);
    }
    // Checks if pairing of public key & hash is equal to pairing of generator & signature.
    // e(P, H(m)) == e(G, S)
    function verify(signature, message, publicKey) {
        const P = normP1(publicKey);
        const Hm = normP2Hash(message);
        const G = G1.Point.BASE;
        const S = normP2(signature);
        // Instead of doing 2 exponentiations, we use property of billinear maps
        // and do one exp after multiplying 2 points.
        const ePHm = pairing(P.negate(), Hm, false);
        const eGS = pairing(G, S, false);
        const exp = Fp12.finalExponentiate(Fp12.mul(eGS, ePHm));
        return Fp12.equals(exp, Fp12.ONE);
    }
    function aggregatePublicKeys(publicKeys) {
        if (!publicKeys.length)
            throw new Error('Expected non-empty array');
        const agg = publicKeys
            .map(normP1)
            .reduce((sum, p) => sum.add(G1.ProjectivePoint.fromAffine(p)), G1.ProjectivePoint.ZERO);
        const aggAffine = agg.toAffine();
        if (publicKeys[0] instanceof G1.Point) {
            aggAffine.assertValidity();
            return aggAffine;
        }
        // toRawBytes ensures point validity
        return aggAffine.toRawBytes(true);
    }
    function aggregateSignatures(signatures) {
        if (!signatures.length)
            throw new Error('Expected non-empty array');
        const agg = signatures
            .map(normP2)
            .reduce((sum, s) => sum.add(G2.ProjectivePoint.fromAffine(s)), G2.ProjectivePoint.ZERO);
        const aggAffine = agg.toAffine();
        if (signatures[0] instanceof G2.Point) {
            aggAffine.assertValidity();
            return aggAffine;
        }
        return Signature.encode(aggAffine);
    }
    // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407
    // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))
    function verifyBatch(signature, messages, publicKeys) {
        if (!messages.length)
            throw new Error('Expected non-empty messages array');
        if (publicKeys.length !== messages.length)
            throw new Error('Pubkey count should equal msg count');
        const sig = normP2(signature);
        const nMessages = messages.map(normP2Hash);
        const nPublicKeys = publicKeys.map(normP1);
        try {
            const paired = [];
            for (const message of new Set(nMessages)) {
                const groupPublicKey = nMessages.reduce((groupPublicKey, subMessage, i) => subMessage === message ? groupPublicKey.add(nPublicKeys[i]) : groupPublicKey, G1.Point.ZERO);
                // const msg = message instanceof PointG2 ? message : await PointG2.hashToCurve(message);
                // Possible to batch pairing for same msg with different groupPublicKey here
                paired.push(pairing(groupPublicKey, message, false));
            }
            paired.push(pairing(G1.Point.BASE.negate(), sig, false));
            const product = paired.reduce((a, b) => Fp12.mul(a, b), Fp12.ONE);
            const exp = Fp12.finalExponentiate(product);
            return Fp12.equals(exp, Fp12.ONE);
        }
        catch {
            return false;
        }
    }
    // Pre-compute points. Refer to README.
    G1.Point.BASE._setWindowSize(4);
    return {
        CURVE,
        Fr,
        Fp,
        Fp2,
        Fp6,
        Fp12,
        G1,
        G2,
        Signature,
        millerLoop,
        calcPairingPrecomputes,
        pairing,
        getPublicKey,
        sign,
        verify,
        aggregatePublicKeys,
        aggregateSignatures,
        verifyBatch,
        utils,
    };
}
