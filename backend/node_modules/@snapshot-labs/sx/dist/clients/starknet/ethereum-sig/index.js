"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthereumSig = void 0;
const starknet_1 = require("starknet");
const randombytes_1 = __importDefault(require("randombytes"));
const snake_case_1 = require("snake-case");
const wallet_1 = require("@ethersproject/wallet");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const types_1 = require("./types");
const split_uint256_1 = require("../../../utils/split-uint256");
const encoding_1 = require("../../../utils/encoding");
const bytes_1 = require("../../../utils/bytes");
const strategies_1 = require("../../../utils/strategies");
const networks_1 = require("../../../networks");
class EthereumSig {
    config;
    constructor(opts) {
        this.config = {
            networkConfig: networks_1.defaultNetwork,
            ...opts
        };
    }
    generateSalt() {
        return Number(split_uint256_1.SplitUint256.fromHex((0, bytes_1.bytesToHex)((0, randombytes_1.default)(4))).toHex());
    }
    async sign(web3, address, message, types) {
        const signer = wallet_1.Wallet.isSigner(web3) ? web3 : web3.getSigner();
        const domain = {
            ...types_1.baseDomain,
            chainId: this.config.networkConfig.eip712ChainId
        };
        const data = { domain, types, message };
        const typedData = Object.fromEntries(Object.entries(message).map(([k, v]) => [(0, snake_case_1.snakeCase)(k), v]));
        const sig = await signer._signTypedData(domain, data.types, typedData);
        return { address, sig, data };
    }
    async send(envelop) {
        const init = {
            method: 'POST',
            headers: {
                Accept: 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                jsonrpc: '2.0',
                method: 'send',
                params: { envelop },
                id: null
            })
        };
        const res = await (0, cross_fetch_1.default)(this.config.manaUrl, init);
        const json = await res.json();
        return json.result;
    }
    async propose(web3, address, data) {
        const strategies = await (0, strategies_1.getStrategies)(data, this.config);
        const strategiesParams = await (0, strategies_1.getStrategiesParams)('propose', strategies, address, data, this.config);
        const message = {
            ...data,
            space: (0, encoding_1.hexPadRight)(data.space),
            authenticator: (0, encoding_1.hexPadRight)(data.authenticator),
            author: address,
            executor: (0, encoding_1.hexPadRight)(data.executor),
            executionHash: (0, encoding_1.hexPadRight)(starknet_1.hash.computeHashOnElements(data.executionParams)),
            strategiesHash: (0, encoding_1.hexPadRight)(starknet_1.hash.computeHashOnElements(data.strategies.map(strategy => `0x${strategy.toString(16)}`))),
            strategiesParamsHash: (0, encoding_1.hexPadRight)(starknet_1.hash.computeHashOnElements((0, encoding_1.flatten2DArray)(strategiesParams))),
            salt: this.generateSalt()
        };
        return this.sign(web3, address, message, types_1.proposeTypes);
    }
    async vote(web3, address, data) {
        const strategies = await (0, strategies_1.getStrategies)(data, this.config);
        const strategiesParams = await (0, strategies_1.getStrategiesParams)('vote', strategies, address, data, this.config);
        const message = {
            ...data,
            space: (0, encoding_1.hexPadRight)(data.space),
            authenticator: (0, encoding_1.hexPadRight)(data.authenticator),
            voter: address,
            strategiesHash: (0, encoding_1.hexPadRight)(starknet_1.hash.computeHashOnElements(data.strategies.map(strategy => `0x${strategy.toString(16)}`))),
            strategiesParamsHash: (0, encoding_1.hexPadRight)(starknet_1.hash.computeHashOnElements((0, encoding_1.flatten2DArray)(strategiesParams))),
            salt: this.generateSalt()
        };
        return this.sign(web3, address, message, types_1.voteTypes);
    }
}
exports.EthereumSig = EthereumSig;
