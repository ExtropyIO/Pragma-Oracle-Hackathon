"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Zodiac = void 0;
const abi_1 = require("@ethersproject/abi");
const contracts_1 = require("@ethersproject/contracts");
const encoding_1 = require("../../../utils/encoding");
const split_uint256_1 = require("../../../utils/split-uint256");
const networks_1 = require("../../../networks");
const zodiac_json_1 = __importDefault(require("./abis/zodiac.json"));
class Zodiac {
    config;
    zodiacInterface;
    constructor(opts) {
        this.config = {
            networkConfig: networks_1.defaultNetwork,
            ...opts
        };
        this.zodiacInterface = new abi_1.Interface(zodiac_json_1.default);
    }
    async receiveProposal(space, executor, input) {
        if (!input?.transactions)
            throw new Error('Expected transactions in input');
        const executorConfig = this.config.networkConfig.executors[executor];
        if (executorConfig?.type !== 'ethRelayer')
            throw new Error('Expected ethRelayer executor');
        const { destination, chainId } = executorConfig.params;
        const zodiacModule = new contracts_1.Contract(destination, this.zodiacInterface, this.config.signer);
        const { executionHash, txHashes } = (0, encoding_1.createExecutionHash)(input.transactions, destination, chainId);
        const executionHashSplit = split_uint256_1.SplitUint256.fromHex(executionHash);
        const proposalOutcome = 1;
        return zodiacModule.receiveProposal(space, proposalOutcome, executionHashSplit.low, executionHashSplit.high, txHashes);
    }
    async executeProposalTx(proposalIndex, executor, transaction) {
        const executorConfig = this.config.networkConfig.executors[executor];
        if (executorConfig?.type !== 'ethRelayer')
            throw new Error('Expected ethRelayer executor');
        const { destination } = executorConfig.params;
        const zodiacModule = new contracts_1.Contract(destination, this.zodiacInterface, this.config.signer);
        return zodiacModule.executeProposalTx(proposalIndex, transaction.to, transaction.value, transaction.data, transaction.operation);
    }
    async executeProposalTxBatch(proposalIndex, executor, transactions) {
        const executorConfig = this.config.networkConfig.executors[executor];
        if (executorConfig?.type !== 'ethRelayer')
            throw new Error('Expected ethRelayer executor');
        const { destination } = executorConfig.params;
        const zodiacModule = new contracts_1.Contract(destination, this.zodiacInterface, this.config.signer);
        const { tos, values, data, operations } = transactions.reduce((acc, transaction) => {
            acc.tos.push(transaction.to);
            acc.values.push(transaction.value);
            acc.data.push(transaction.data);
            acc.operations.push(transaction.operation);
            return acc;
        }, {
            tos: [],
            values: [],
            data: [],
            operations: []
        });
        return zodiacModule.executeProposalTxBatch(proposalIndex, tos, values, data, operations);
    }
}
exports.Zodiac = Zodiac;
