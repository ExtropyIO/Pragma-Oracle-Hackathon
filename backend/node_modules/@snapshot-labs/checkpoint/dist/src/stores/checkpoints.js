"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckpointsStore = exports.getCheckpointId = exports.MetadataId = void 0;
const crypto = __importStar(require("crypto"));
const Table = {
    Checkpoints: '_checkpoints',
    Metadata: '_metadatas',
    TemplateSources: '_template_sources'
};
const Fields = {
    Checkpoints: {
        Id: 'id',
        BlockNumber: 'block_number',
        ContractAddress: 'contract_address'
    },
    Metadata: {
        Id: 'id',
        Value: 'value'
    },
    TemplateSources: {
        Id: 'id',
        ContractAddress: 'contract_address',
        StartBlock: 'start_block',
        Template: 'template'
    }
};
/**
 * Metadata Ids stored in the CheckpointStore.
 *
 */
var MetadataId;
(function (MetadataId) {
    MetadataId["LastIndexedBlock"] = "last_indexed_block";
    MetadataId["NetworkIdentifier"] = "network_identifier";
    MetadataId["StartBlock"] = "start_block";
    MetadataId["ConfigChecksum"] = "config_checksum";
})(MetadataId = exports.MetadataId || (exports.MetadataId = {}));
const CheckpointIdSize = 10;
/**
 * Generates a unique hex based on the contract address and block number.
 * Used when as id for storing checkpoints records.
 *
 */
const getCheckpointId = (contract, block) => {
    const data = `${contract}${block}`;
    return crypto.createHash('sha256').update(data).digest('hex').slice(-CheckpointIdSize);
};
exports.getCheckpointId = getCheckpointId;
/**
 * Checkpoints store is a data store class for managing
 * checkpoints data schema and records.
 *
 * It interacts with an underlying database.
 */
class CheckpointsStore {
    knex;
    log;
    constructor(knex, log) {
        this.knex = knex;
        this.log = log.child({ component: 'checkpoints_store' });
    }
    /**
     * Creates the core database tables to make Checkpoint run effectively.
     *
     * This only creates the tables if they don't exist.
     */
    async createStore() {
        this.log.debug('creating checkpoints tables...');
        const hasCheckpointsTable = await this.knex.schema.hasTable(Table.Checkpoints);
        const hasMetadataTable = await this.knex.schema.hasTable(Table.Metadata);
        const hasTemplateSourcesTable = await this.knex.schema.hasTable(Table.TemplateSources);
        let builder = this.knex.schema;
        if (!hasCheckpointsTable) {
            builder = builder.createTable(Table.Checkpoints, t => {
                t.string(Fields.Checkpoints.Id, CheckpointIdSize).primary();
                t.bigint(Fields.Checkpoints.BlockNumber).notNullable();
                t.string(Fields.Checkpoints.ContractAddress, 66).notNullable();
            });
        }
        if (!hasMetadataTable) {
            builder = builder.dropTableIfExists(Table.Metadata).createTable(Table.Metadata, t => {
                t.string(Fields.Metadata.Id, 20).primary();
                t.string(Fields.Metadata.Value, 128).notNullable();
            });
        }
        if (!hasTemplateSourcesTable) {
            builder = builder
                .dropTableIfExists(Table.TemplateSources)
                .createTable(Table.TemplateSources, t => {
                t.increments(Fields.TemplateSources.Id);
                t.string(Fields.TemplateSources.ContractAddress, 66);
                t.bigint(Fields.TemplateSources.StartBlock).notNullable();
                t.string(Fields.TemplateSources.Template, 128).notNullable();
            });
        }
        await builder;
        this.log.debug('checkpoints tables created');
        return { builder };
    }
    /**
     * Truncates core database tables.
     *
     * Calling it will cause all checkpoints to be deleted and will force
     * syncing to start from start.
     *
     */
    async resetStore() {
        this.log.debug('truncating checkpoints tables');
        const hasCheckpointsTable = await this.knex.schema.hasTable(Table.Checkpoints);
        const hasMetadataTable = await this.knex.schema.hasTable(Table.Metadata);
        const hasTemplateSourcesTable = await this.knex.schema.hasTable(Table.TemplateSources);
        if (hasCheckpointsTable) {
            await this.knex(Table.Checkpoints).truncate();
        }
        if (hasMetadataTable) {
            await this.knex(Table.Metadata).truncate();
        }
        if (hasTemplateSourcesTable) {
            await this.knex(Table.TemplateSources).truncate();
        }
        this.log.debug('checkpoints tables truncated');
    }
    async getMetadata(id) {
        const value = await this.knex
            .select(Fields.Metadata.Value)
            .from(Table.Metadata)
            .where(Fields.Metadata.Id, id)
            .limit(1);
        if (value.length == 0) {
            return null;
        }
        return value[0][Fields.Metadata.Value];
    }
    async getMetadataNumber(id, base = 10) {
        const strValue = await this.getMetadata(id);
        if (!strValue) {
            return undefined;
        }
        return parseInt(strValue, base);
    }
    async setMetadata(id, value) {
        await this.knex
            .table(Table.Metadata)
            .insert({
            [Fields.Metadata.Id]: id,
            [Fields.Metadata.Value]: value
        })
            .onConflict(Fields.Metadata.Id)
            .merge();
    }
    async insertCheckpoints(checkpoints) {
        if (checkpoints.length === 0) {
            return;
        }
        await this.knex
            .table(Table.Checkpoints)
            .insert(checkpoints.map(checkpoint => {
            const id = (0, exports.getCheckpointId)(checkpoint.contractAddress, checkpoint.blockNumber);
            return {
                [Fields.Checkpoints.Id]: id,
                [Fields.Checkpoints.BlockNumber]: checkpoint.blockNumber,
                [Fields.Checkpoints.ContractAddress]: checkpoint.contractAddress
            };
        }))
            .onConflict(Fields.Checkpoints.Id)
            .ignore();
    }
    /**
     * Fetch list of checkpoint blocks greater than or equal to the
     * block number arguments, that have some events related to the
     * contracts in the lists.
     *
     * By default this returns at most 15 next blocks. This return limit
     * can be modified by the limit command.
     */
    async getNextCheckpointBlocks(block, contracts, limit = 15) {
        const result = await this.knex
            .select(Fields.Checkpoints.BlockNumber)
            .from(Table.Checkpoints)
            .where(Fields.Checkpoints.BlockNumber, '>=', block)
            .whereIn(Fields.Checkpoints.ContractAddress, contracts)
            .orderBy(Fields.Checkpoints.BlockNumber, 'asc')
            .limit(limit);
        this.log.debug({ result, block, contracts }, 'next checkpoint blocks');
        return result.map(value => Number(value[Fields.Checkpoints.BlockNumber]));
    }
    async insertTemplateSource(contractAddress, startBlock, template) {
        return this.knex.table(Table.TemplateSources).insert({
            [Fields.TemplateSources.ContractAddress]: contractAddress,
            [Fields.TemplateSources.StartBlock]: startBlock,
            [Fields.TemplateSources.Template]: template
        });
    }
    async getTemplateSources() {
        const data = await this.knex
            .select(Fields.TemplateSources.ContractAddress, Fields.TemplateSources.StartBlock, Fields.TemplateSources.Template)
            .from(Table.TemplateSources);
        return data.map(row => ({
            contractAddress: row[Fields.TemplateSources.ContractAddress],
            startBlock: row[Fields.TemplateSources.StartBlock],
            template: row[Fields.TemplateSources.Template]
        }));
    }
}
exports.CheckpointsStore = CheckpointsStore;
