"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bluebird_1 = __importDefault(require("bluebird"));
const graphql_1 = require("graphql");
const schema_1 = require("@graphql-tools/schema");
const graphql_2 = __importStar(require("./graphql"));
const controller_1 = require("./graphql/controller");
const checkpoints_1 = require("./stores/checkpoints");
const providers_1 = require("./providers");
const logger_1 = require("./utils/logger");
const checkpoint_1 = require("./utils/checkpoint");
const graphql_3 = require("./utils/graphql");
const knex_1 = require("./knex");
const mysql_1 = require("./mysql");
const pg_1 = require("./pg");
const schemas_1 = require("./schemas");
const register_1 = require("./register");
const DEFAULT_FETCH_INTERVAL = 7000;
class Checkpoint {
    config;
    writer;
    opts;
    schema;
    entityController;
    log;
    networkProvider;
    dbConnection;
    knex;
    mysqlPool;
    pgPool;
    checkpointsStore;
    activeTemplates = [];
    sourceContracts;
    cpBlocksCache;
    constructor(config, writer, schema, opts) {
        const validationResult = schemas_1.checkpointConfigSchema.safeParse(config);
        if (validationResult.success === false) {
            throw new Error(`Checkpoint config is invalid: ${validationResult.error.message}`);
        }
        this.config = config;
        this.writer = writer;
        this.opts = opts;
        this.schema = (0, graphql_3.extendSchema)(schema);
        this.validateConfig();
        this.entityController = new controller_1.GqlEntityController(this.schema, config);
        this.sourceContracts = (0, checkpoint_1.getContractsFromConfig)(config);
        this.cpBlocksCache = [];
        this.log = (0, logger_1.createLogger)({
            base: { component: 'checkpoint' },
            level: opts?.logLevel || logger_1.LogLevel.Error,
            ...(opts?.prettifyLogs
                ? {
                    transport: {
                        target: 'pino-pretty'
                    }
                }
                : {})
        });
        const NetworkProvider = opts?.NetworkProvider || providers_1.StarknetProvider;
        this.networkProvider = new NetworkProvider({ instance: this, log: this.log, abis: opts?.abis });
        const dbConnection = opts?.dbConnection || process.env.DATABASE_URL;
        if (!dbConnection) {
            throw new Error('a valid connection string or DATABASE_URL environment variable is required to connect to the database');
        }
        this.knex = (0, knex_1.createKnex)(dbConnection);
        this.dbConnection = dbConnection;
        register_1.register.setKnex(this.knex);
    }
    getBaseContext() {
        return {
            log: this.log.child({ component: 'resolver' }),
            knex: this.knex,
            mysql: this.mysql,
            pg: this.pg
        };
    }
    getSchema() {
        const entityQueryFields = this.entityController.generateQueryFields();
        const coreQueryFields = this.entityController.generateQueryFields([
            graphql_2.MetadataGraphQLObject,
            graphql_2.CheckpointsGraphQLObject
        ]);
        const query = new graphql_1.GraphQLObjectType({
            name: 'Query',
            fields: {
                ...entityQueryFields,
                ...coreQueryFields
            }
        });
        return (0, schema_1.addResolversToSchema)({
            schema: new graphql_1.GraphQLSchema({ query }),
            resolvers: this.entityController.generateEntityResolvers(entityQueryFields)
        });
    }
    /**
     * Returns an express handler that exposes a GraphQL API to query entities defined
     * in the schema.
     *
     */
    get graphql() {
        const schema = this.getSchema();
        return (0, graphql_2.default)(schema, this.getBaseContext(), this.entityController.generateSampleQuery());
    }
    getCurrentSources(blockNumber) {
        if (!this.config.sources)
            return [];
        return this.config.sources.filter(source => source.start <= blockNumber);
    }
    /**
     * Starts the indexer.
     *
     * The indexer will invoker the respective writer functions when a contract
     * event is found.
     *
     */
    async start() {
        this.log.debug('starting');
        await this.validateStore();
        const templateSources = await this.store.getTemplateSources();
        await bluebird_1.default.all(templateSources.map(source => {
            this.executeTemplate(source.template, {
                contract: source.contractAddress,
                start: source.startBlock
            }, false);
        }));
        const blockNum = await this.getStartBlockNum();
        return await this.next(blockNum);
    }
    /**
     * Reset will clear the last synced block informations
     * and force Checkpoint to start indexing from the start
     * block.
     *
     * This will also clear all indexed GraphQL entity records.
     *
     * This should be called when there has been a change to the GraphQL schema
     * or a change to the writer functions logic, so indexing will re-run from
     * the starting block. Also, it should be called the first time Checkpoint
     * is being initialized.
     *
     */
    async reset() {
        this.log.debug('reset');
        await this.store.createStore();
        await this.store.setMetadata(checkpoints_1.MetadataId.LastIndexedBlock, 0);
        await this.entityController.createEntityStores(this.knex);
    }
    /**
     * Resets Checkpoint's internal tables (including checkpoints).
     *
     * Calling this function will cause next run of checkpoint to start syncing
     * from the start, block-by-block, until new checkpoints are found.
     *
     */
    async resetMetadata() {
        this.log.debug('reset metadata');
        await this.store.resetStore();
    }
    addSource(source) {
        if (!this.config.sources)
            this.config.sources = [];
        this.config.sources.push(source);
        this.sourceContracts = (0, checkpoint_1.getContractsFromConfig)(this.config);
        this.cpBlocksCache = [];
    }
    async executeTemplate(name, { contract, start }, persist = true) {
        const template = this.config.templates?.[name];
        if (!template) {
            this.log.warn({ name }, 'template not found');
            return;
        }
        const existingTemplate = this.activeTemplates.find(template => template.template === name &&
            template.contractAddress === contract &&
            template.startBlock === start);
        if (existingTemplate)
            return;
        this.activeTemplates.push({ template: name, contractAddress: contract, startBlock: start });
        if (persist) {
            await this.store.insertTemplateSource(contract, start, name);
        }
        this.addSource({
            contract,
            start,
            abi: template.abi,
            events: template.events
        });
    }
    /**
     * Registers the blocks where a contracts event can be found.
     * This will be used as a skip list for checkpoints while
     * indexing relevant blocks. Using this seed function can significantly
     * reduce the time for Checkpoint to re-index blocks.
     *
     * This should be called before the start() method is called.
     *
     */
    async seedCheckpoints(checkpointBlocks) {
        await this.store.createStore();
        const checkpoints = [];
        checkpointBlocks.forEach(cp => {
            cp.blocks.forEach(blockNumber => {
                checkpoints.push({ blockNumber, contractAddress: cp.contract });
            });
        });
        await this.store.insertCheckpoints(checkpoints);
    }
    async setLastIndexedBlock(block) {
        await this.store.setMetadata(checkpoints_1.MetadataId.LastIndexedBlock, block);
    }
    async insertCheckpoints(checkpoints) {
        await this.store.insertCheckpoints(checkpoints);
    }
    async getWriterParams() {
        return {
            instance: this,
            mysql: this.mysql,
            pg: this.pg
        };
    }
    getConfigStartBlock() {
        if (this.config.start && (this.config.tx_fn || this.config.global_events)) {
            return this.config.start;
        }
        return Math.min(...(this.config.sources?.map(source => source.start) || []));
    }
    async getStartBlockNum() {
        const start = this.getConfigStartBlock();
        const lastBlock = (await this.store.getMetadataNumber(checkpoints_1.MetadataId.LastIndexedBlock)) ?? 0;
        const nextBlock = lastBlock + 1;
        return nextBlock > start ? nextBlock : start;
    }
    async next(blockNum) {
        if (!this.config.tx_fn && !this.config.global_events) {
            const checkpointBlock = await this.getNextCheckpointBlock(blockNum);
            if (checkpointBlock)
                blockNum = checkpointBlock;
        }
        this.log.debug({ blockNumber: blockNum }, 'next block');
        try {
            const nextBlock = await this.networkProvider.processBlock(blockNum);
            return this.next(nextBlock);
        }
        catch (err) {
            if (this.config.optimistic_indexing && err instanceof providers_1.BlockNotFoundError) {
                try {
                    await this.networkProvider.processPool(blockNum);
                }
                catch (err) {
                    this.log.error({ blockNumber: blockNum, err }, 'error occurred during pool processing');
                }
            }
            else {
                this.log.error({ blockNumber: blockNum, err }, 'error occurred during block processing');
            }
            await bluebird_1.default.delay(this.opts?.fetchInterval || DEFAULT_FETCH_INTERVAL);
            return this.next(blockNum);
        }
    }
    async getNextCheckpointBlock(blockNum) {
        if (this.cpBlocksCache === null) {
            // cache is null when we can no more find a record in the database
            // so exiting early here to avoid polling the database in subsequent
            // loops.
            return null;
        }
        if (this.cpBlocksCache.length !== 0) {
            return this.cpBlocksCache.shift();
        }
        const checkpointBlocks = await this.store.getNextCheckpointBlocks(blockNum, this.sourceContracts);
        if (checkpointBlocks.length === 0) {
            this.log.info({ blockNumber: blockNum }, 'no more checkpoint blocks in store');
            // disabling cache to stop polling database
            this.cpBlocksCache = null;
            return null;
        }
        this.cpBlocksCache = checkpointBlocks;
        return this.cpBlocksCache.shift();
    }
    get store() {
        if (this.checkpointsStore) {
            return this.checkpointsStore;
        }
        return (this.checkpointsStore = new checkpoints_1.CheckpointsStore(this.knex, this.log));
    }
    /**
     * returns AsyncMySqlPool if mysql client is used, otherwise returns Proxy that
     * will notify user when used that mysql is not available with other clients
     */
    get mysql() {
        if (this.mysqlPool) {
            return this.mysqlPool;
        }
        if (this.knex.client.config.client === 'mysql') {
            this.mysqlPool = (0, mysql_1.createMySqlPool)(this.dbConnection);
            return this.mysqlPool;
        }
        return new Proxy({}, {
            get() {
                throw new Error('mysql is only accessible when using MySQL database.');
            }
        });
    }
    /**
     * returns pg's Pool if pg client is used, otherwise returns Proxy that
     * will notify user when used that mysql is not available with other clients
     */
    get pg() {
        if (this.pgPool) {
            return this.pgPool;
        }
        if (this.knex.client.config.client === 'pg') {
            this.pgPool = (0, pg_1.createPgPool)(this.dbConnection);
            return this.pgPool;
        }
        return new Proxy({}, {
            get() {
                throw new Error('pg is only accessible when using PostgreSQL database.');
            }
        });
    }
    validateConfig() {
        const sources = this.config.sources ?? [];
        const templates = Object.values(this.config.templates ?? {});
        const usedAbis = [
            ...sources.map(source => source.abi),
            ...templates.map(template => template.abi)
        ].filter(abi => abi);
        const usedWriters = [
            ...sources.flatMap(source => source.events),
            ...templates.flatMap(template => template.events)
        ];
        const missingAbis = usedAbis.filter(abi => !this.opts?.abis?.[abi]);
        const missingWriters = usedWriters.filter(writer => !this.writer[writer.fn]);
        if (missingAbis.length > 0) {
            throw new Error(`Following ABIs are used (${missingAbis.join(', ')}), but they are missing in opts.abis`);
        }
        if (missingWriters.length > 0) {
            throw new Error(`Following writers are used (${missingWriters
                .map(writer => writer.fn)
                .join(', ')}), but they are not defined`);
        }
    }
    async validateStore() {
        const networkIdentifier = await this.networkProvider.getNetworkIdentifier();
        const configChecksum = (0, checkpoint_1.getConfigChecksum)(this.config);
        const storedNetworkIdentifier = await this.store.getMetadata(checkpoints_1.MetadataId.NetworkIdentifier);
        const storedStartBlock = await this.store.getMetadataNumber(checkpoints_1.MetadataId.StartBlock);
        const storedConfigChecksum = await this.store.getMetadata(checkpoints_1.MetadataId.ConfigChecksum);
        const hasNetworkChanged = storedNetworkIdentifier && storedNetworkIdentifier !== networkIdentifier;
        const hasStartBlockChanged = storedStartBlock && storedStartBlock !== this.getConfigStartBlock();
        const hasConfigChanged = storedConfigChecksum && storedConfigChecksum !== configChecksum;
        if ((hasNetworkChanged || hasStartBlockChanged || hasConfigChanged) &&
            this.opts?.resetOnConfigChange) {
            await this.resetMetadata();
            await this.reset();
            await this.store.setMetadata(checkpoints_1.MetadataId.NetworkIdentifier, networkIdentifier);
            await this.store.setMetadata(checkpoints_1.MetadataId.StartBlock, this.getConfigStartBlock());
            await this.store.setMetadata(checkpoints_1.MetadataId.ConfigChecksum, configChecksum);
        }
        else if (hasNetworkChanged) {
            this.log.error(`network identifier changed from ${storedNetworkIdentifier} to ${networkIdentifier}.
        You probably should reset the database by calling .reset() and resetMetadata().
          You can also set resetOnConfigChange to true in Checkpoint options to do this automatically.`);
            throw new Error('network identifier changed');
        }
        else if (hasStartBlockChanged) {
            this.log.error(`start block changed from ${storedStartBlock} to ${this.getConfigStartBlock()}.
        You probably should reset the database by calling .reset() and resetMetadata().
        You can also set resetOnConfigChange to true in Checkpoint options to do this automatically.`);
            throw new Error('start block changed');
        }
        else if (hasConfigChanged) {
            this.log.error(`config checksum changed from ${storedConfigChecksum} to ${configChecksum} to due to a change in the config.
          You probably should reset the database by calling .reset() and resetMetadata().
          You can also set resetOnConfigChange to true in Checkpoint options to do this automatically.`);
            throw new Error('config changed');
        }
        else {
            if (!storedNetworkIdentifier) {
                await this.store.setMetadata(checkpoints_1.MetadataId.NetworkIdentifier, networkIdentifier);
            }
            if (!storedStartBlock) {
                await this.store.setMetadata(checkpoints_1.MetadataId.StartBlock, this.getConfigStartBlock());
            }
            if (!storedConfigChecksum) {
                await this.store.setMetadata(checkpoints_1.MetadataId.ConfigChecksum, configChecksum);
            }
        }
    }
}
exports.default = Checkpoint;
