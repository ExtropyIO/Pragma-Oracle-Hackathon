/// <reference types="node" />
import Promise from 'bluebird';
import { GraphQLSchema } from 'graphql';
import { Knex } from 'knex';
import { Pool as PgPool } from 'pg';
import { AsyncMySqlPool } from './mysql';
import { CheckpointConfig, CheckpointOptions, CheckpointWriters } from './types';
export default class Checkpoint {
    config: CheckpointConfig;
    writer: CheckpointWriters;
    opts?: CheckpointOptions;
    schema: string;
    private readonly entityController;
    private readonly log;
    private readonly networkProvider;
    private dbConnection;
    private knex;
    private mysqlPool?;
    private pgPool?;
    private checkpointsStore?;
    private activeTemplates;
    private sourceContracts;
    private cpBlocksCache;
    constructor(config: CheckpointConfig, writer: CheckpointWriters, schema: string, opts?: CheckpointOptions);
    getBaseContext(): {
        log: import("pino").default.Logger<import("pino").LoggerOptions & import("pino").default.ChildLoggerOptions>;
        knex: Knex<any, any[]>;
        mysql: AsyncMySqlPool;
        pg: PgPool;
    };
    getSchema(): GraphQLSchema;
    /**
     * Returns an express handler that exposes a GraphQL API to query entities defined
     * in the schema.
     *
     */
    get graphql(): (request: import("http").IncomingMessage & {
        url: string;
    }, response: import("http").ServerResponse<import("http").IncomingMessage> & {
        json?: ((data: unknown) => void) | undefined;
    }) => Promise<void>;
    getCurrentSources(blockNumber: number): {
        start: number;
        contract: string;
        events: {
            name: string;
            fn: string;
        }[];
        abi?: string | undefined;
        deploy_fn?: string | undefined;
    }[];
    /**
     * Starts the indexer.
     *
     * The indexer will invoker the respective writer functions when a contract
     * event is found.
     *
     */
    start(): Promise<any>;
    /**
     * Reset will clear the last synced block informations
     * and force Checkpoint to start indexing from the start
     * block.
     *
     * This will also clear all indexed GraphQL entity records.
     *
     * This should be called when there has been a change to the GraphQL schema
     * or a change to the writer functions logic, so indexing will re-run from
     * the starting block. Also, it should be called the first time Checkpoint
     * is being initialized.
     *
     */
    reset(): Promise<void>;
    /**
     * Resets Checkpoint's internal tables (including checkpoints).
     *
     * Calling this function will cause next run of checkpoint to start syncing
     * from the start, block-by-block, until new checkpoints are found.
     *
     */
    resetMetadata(): Promise<void>;
    private addSource;
    executeTemplate(name: string, { contract, start }: {
        contract: string;
        start: number;
    }, persist?: boolean): Promise<void>;
    /**
     * Registers the blocks where a contracts event can be found.
     * This will be used as a skip list for checkpoints while
     * indexing relevant blocks. Using this seed function can significantly
     * reduce the time for Checkpoint to re-index blocks.
     *
     * This should be called before the start() method is called.
     *
     */
    seedCheckpoints(checkpointBlocks: {
        contract: string;
        blocks: number[];
    }[]): Promise<void>;
    setLastIndexedBlock(block: number): Promise<void>;
    insertCheckpoints(checkpoints: {
        blockNumber: number;
        contractAddress: string;
    }[]): Promise<void>;
    getWriterParams(): Promise<{
        instance: Checkpoint;
        knex: Knex;
        mysql: AsyncMySqlPool;
        pg: PgPool;
    }>;
    private getConfigStartBlock;
    private getStartBlockNum;
    private next;
    private getNextCheckpointBlock;
    private get store();
    /**
     * returns AsyncMySqlPool if mysql client is used, otherwise returns Proxy that
     * will notify user when used that mysql is not available with other clients
     */
    private get mysql();
    /**
     * returns pg's Pool if pg client is used, otherwise returns Proxy that
     * will notify user when used that mysql is not available with other clients
     */
    private get pg();
    private validateConfig;
    private validateStore;
}
