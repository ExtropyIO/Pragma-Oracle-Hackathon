"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GqlEntityController = void 0;
const graphql_1 = require("graphql");
const pluralize_1 = __importDefault(require("pluralize"));
const graphql_2 = require("../utils/graphql");
const resolvers_1 = require("./resolvers");
const GraphQLOrderDirection = new graphql_1.GraphQLEnumType({
    name: 'OrderDirection',
    values: {
        asc: { value: 'ASC' },
        desc: { value: 'DESC' }
    }
});
/**
 * Controller for performing actions based on the graphql schema provided to its
 * constructor. It exposes public functions to generate graphql or database
 * items based on the entities identified in the schema.
 *
 * Note: Entities refer to Object types with an `id` field defined within the
 * graphql schema.
 */
class GqlEntityController {
    schema;
    decimalTypes;
    _schemaObjects;
    constructor(typeDefs, config) {
        this.schema = (0, graphql_1.buildSchema)(typeDefs);
        this.decimalTypes = config?.decimal_types || {
            Decimal: {
                p: 10,
                d: 2
            },
            BigDecimal: {
                p: 20,
                d: 8
            }
        };
    }
    /**
     * Creates a grqphql Query object generated from the objects defined within
     * the schema.
     * For each of the objects, two queries are created, one for querying the object
     * by it's id and the second for querying multiple objects based on a couple
     * of parameters.
     *
     * For example, given the input schema:
     * ```
     * type Vote {
     *  id: Int!
     *  name: String
     * }
     * ```
     *
     * The generated queries will be like:
     * ```
     * type Query {
     *  votes(
     *     first: Int
     *     skip: Int
     *     orderBy: String
     *     orderDirection: String
     *     where: WhereVote
     *   ): [Vote]
     *   vote(id: Int!): Vote
     * }
     *
     *  input WhereVote {
     *    id: Int
     *    id_in: [Int]
     *    name: String
     *    name_in: [String]
     *  }
     *
     * ```
     *
     */
    generateQueryFields(schemaObjects, resolvers = {
        singleEntityResolver: resolvers_1.querySingle,
        multipleEntityResolver: resolvers_1.queryMulti
    }) {
        schemaObjects = schemaObjects || this.schemaObjects;
        const queryFields = {};
        schemaObjects.forEach(type => {
            queryFields[(0, graphql_2.singleEntityQueryName)(type)] = this.getSingleEntityQueryConfig(type, resolvers.singleEntityResolver);
            queryFields[(0, graphql_2.multiEntityQueryName)(type)] = this.getMultipleEntityQueryConfig(type, resolvers.multipleEntityResolver);
        });
        return queryFields;
    }
    /**
     * Generates entity resolvers for subqueries.
     * Returned resolvers use format compatible with addResolversToSchema.
     * {
     *   Proposal: {
     *     space: () => {}
     *   }
     * }
     */
    generateEntityResolvers(fields) {
        return this.schemaObjects.reduce((entities, obj) => {
            entities[obj.name] = this.getTypeFields(obj).reduce((resolvers, field) => {
                const nonNullType = (0, graphql_2.getNonNullType)(field.type);
                if ((0, graphql_1.isListType)(nonNullType) && nonNullType.ofType instanceof graphql_1.GraphQLObjectType) {
                    resolvers[field.name] = (0, resolvers_1.getNestedResolver)((0, graphql_2.multiEntityQueryName)(nonNullType.ofType));
                }
                if (nonNullType instanceof graphql_1.GraphQLObjectType) {
                    resolvers[field.name] = fields[(0, graphql_2.singleEntityQueryName)(nonNullType)].resolve;
                }
                return resolvers;
            }, {});
            return entities;
        }, {});
    }
    /**
     * Creates store for each of the objects in the schema.
     * For now, it only creates database tables for each of the objects.
     * It also creates a checkpoint table to track checkpoints visited.
     *
     * For example, given an schema like:
     * ```graphql
     * type Vote {
     *  id: Int!
     *  name: String
     * }
     * ```
     *
     * will execute the following SQL:
     * ```sql
     * DROP TABLE IF EXISTS votes;
     * CREATE TABLE votes (
     *   id VARCHAR(128) NOT NULL,
     *   name VARCHAR(128),
     *   PRIMARY KEY (id) ,
     *   INDEX id (id),
     *   INDEX name (name)
     * );
     * ```
     *
     */
    async createEntityStores(knex) {
        let builder = knex.schema;
        if (this.schemaObjects.length === 0) {
            return { builder };
        }
        this.schemaObjects.map(type => {
            const tableName = (0, pluralize_1.default)(type.name.toLowerCase());
            builder = builder.dropTableIfExists(tableName).createTable(tableName, t => {
                t.primary(['id']);
                this.getTypeFields(type).forEach(field => {
                    const fieldType = field.type instanceof graphql_1.GraphQLNonNull ? field.type.ofType : field.type;
                    if ((0, graphql_1.isListType)(fieldType) && fieldType.ofType instanceof graphql_1.GraphQLObjectType)
                        return;
                    const sqlType = this.getSqlType(field.type);
                    let column = 'options' in sqlType
                        ? t[sqlType.name](field.name, ...sqlType.options)
                        : t[sqlType.name](field.name);
                    if (field.type instanceof graphql_1.GraphQLNonNull) {
                        column = column.notNullable();
                    }
                    if (!['text', 'json'].includes(sqlType.name)) {
                        column.index();
                    }
                });
            });
        });
        await builder;
        return { builder };
    }
    /**
     * Generates a query based on the first entity discovered
     * in a schema. If no entities are found in the schema
     * it returns undefined.
     *
     */
    generateSampleQuery() {
        if (this.schemaObjects.length === 0) {
            return undefined;
        }
        const firstEntityQuery = (0, graphql_2.generateQueryForEntity)(this.schemaObjects[0]);
        const queryComment = `
# Welcome to Checkpoint. Try running the below example query from
# your defined entity.
    `;
        return `${queryComment}\n${firstEntityQuery}`;
    }
    /**
     * Returns a list of objects defined within the graphql typedefs.
     * The types returns are introspection objects, that can be used
     * for inspecting the fields and types.
     *
     * Note: that the returned objects does not include the Query object type if defined.
     *
     */
    get schemaObjects() {
        if (this._schemaObjects) {
            return this._schemaObjects;
        }
        this._schemaObjects = Object.values(this.schema.getTypeMap()).filter(type => {
            return (type instanceof graphql_1.GraphQLObjectType && type.name != 'Query' && !type.name.startsWith('__'));
        });
        return this._schemaObjects;
    }
    getTypeFields(type) {
        return Object.values(type.getFields());
    }
    getSingleEntityQueryConfig(type, resolver) {
        return {
            type,
            args: {
                id: { type: new graphql_1.GraphQLNonNull(this.getEntityIdType(type)) }
            },
            resolve: resolver
        };
    }
    getMultipleEntityQueryConfig(type, resolver) {
        const whereInputConfig = {
            name: `Where${type.name}`,
            fields: {}
        };
        const orderByValues = {};
        this.getTypeFields(type).forEach(field => {
            // all field types in a where input variable must be optional
            // so we try to extract the non null type here.
            let nonNullFieldType = (0, graphql_2.getNonNullType)(field.type);
            if (nonNullFieldType instanceof graphql_1.GraphQLObjectType) {
                const fields = type.getFields();
                const idField = fields['id'];
                if (idField &&
                    idField.type instanceof graphql_1.GraphQLNonNull &&
                    idField.type.ofType instanceof graphql_1.GraphQLScalarType &&
                    ['String', 'ID'].includes(idField.type.ofType.name)) {
                    nonNullFieldType = (0, graphql_2.getNonNullType)(idField.type);
                }
            }
            // avoid setting up where filters for non scalar types
            if (!(0, graphql_1.isLeafType)(nonNullFieldType)) {
                return;
            }
            if (nonNullFieldType === graphql_1.GraphQLInt) {
                whereInputConfig.fields[`${field.name}_gt`] = { type: graphql_1.GraphQLInt };
                whereInputConfig.fields[`${field.name}_gte`] = { type: graphql_1.GraphQLInt };
                whereInputConfig.fields[`${field.name}_lt`] = { type: graphql_1.GraphQLInt };
                whereInputConfig.fields[`${field.name}_lte`] = { type: graphql_1.GraphQLInt };
            }
            if ((nonNullFieldType instanceof graphql_1.GraphQLScalarType && nonNullFieldType.name === 'BigInt') ||
                this.decimalTypes[nonNullFieldType.name]) {
                whereInputConfig.fields[`${field.name}_gt`] = { type: nonNullFieldType };
                whereInputConfig.fields[`${field.name}_gte`] = { type: nonNullFieldType };
                whereInputConfig.fields[`${field.name}_lt`] = { type: nonNullFieldType };
                whereInputConfig.fields[`${field.name}_lte`] = { type: nonNullFieldType };
            }
            if (nonNullFieldType === graphql_1.GraphQLString ||
                nonNullFieldType.name === 'Text') {
                whereInputConfig.fields[`${field.name}_contains`] = { type: graphql_1.GraphQLString };
                whereInputConfig.fields[`${field.name}_not_contains`] = { type: graphql_1.GraphQLString };
                whereInputConfig.fields[`${field.name}_contains_nocase`] = { type: graphql_1.GraphQLString };
                whereInputConfig.fields[`${field.name}_not_contains_nocase`] = { type: graphql_1.GraphQLString };
            }
            if (nonNullFieldType.name !== 'Text') {
                whereInputConfig.fields[`${field.name}`] = { type: nonNullFieldType };
                whereInputConfig.fields[`${field.name}_not`] = { type: nonNullFieldType };
                whereInputConfig.fields[`${field.name}_in`] = {
                    type: new graphql_1.GraphQLList(nonNullFieldType)
                };
                whereInputConfig.fields[`${field.name}_not_in`] = {
                    type: new graphql_1.GraphQLList(nonNullFieldType)
                };
            }
            // add fields to orderBy enum
            orderByValues[field.name] = { value: field.name };
        });
        const OrderByEnum = new graphql_1.GraphQLEnumType({
            name: `OrderBy${type.name}Fields`,
            values: orderByValues
        });
        return {
            type: new graphql_1.GraphQLList(type),
            args: {
                first: {
                    type: graphql_1.GraphQLInt
                },
                skip: {
                    type: graphql_1.GraphQLInt
                },
                orderBy: {
                    type: OrderByEnum
                },
                orderDirection: {
                    type: GraphQLOrderDirection
                },
                where: { type: new graphql_1.GraphQLInputObjectType(whereInputConfig) }
            },
            resolve: resolver
        };
    }
    getEntityIdType(type) {
        const idField = type.getFields().id;
        if (!idField) {
            throw new Error(`'id' field is missing in type '${type.name}'. All types are required to have an id field.`);
        }
        if (!(idField.type instanceof graphql_1.GraphQLNonNull)) {
            throw new Error(`'id' field for type ${type.name} must be non nullable.`);
        }
        const nonNullType = idField.type.ofType;
        // verify only scalar types are used
        if (!(nonNullType instanceof graphql_1.GraphQLScalarType)) {
            throw new Error(`'id' field for type ${type.name} is not a scalar type.`);
        }
        return nonNullType;
    }
    /**
     * Return a knex column type and options for the graphql type.
     *
     * It throws if the type is not a recognized type.
     */
    getSqlType(type) {
        if (type instanceof graphql_1.GraphQLNonNull) {
            type = type.ofType;
        }
        switch (type) {
            case graphql_1.GraphQLInt:
                return { name: 'integer' };
            case graphql_1.GraphQLFloat:
                return { name: 'float', options: [23] };
            case graphql_1.GraphQLString:
            case graphql_1.GraphQLID:
                return { name: 'string', options: [128] };
        }
        if (type instanceof graphql_1.GraphQLObjectType) {
            const fields = type.getFields();
            const idField = fields['id'];
            if (idField &&
                idField.type instanceof graphql_1.GraphQLNonNull &&
                idField.type.ofType instanceof graphql_1.GraphQLScalarType &&
                ['String', 'ID'].includes(idField.type.ofType.name)) {
                return { name: 'string', options: [128] };
            }
        }
        // check for TEXT scalar type
        if (type instanceof graphql_1.GraphQLScalarType && type.name === 'Text') {
            return { name: 'text' };
        }
        if (type instanceof graphql_1.GraphQLScalarType && type.name === 'BigInt') {
            return { name: 'bigint' };
        }
        if (type instanceof graphql_1.GraphQLScalarType && type.name === 'Boolean') {
            return { name: 'boolean' };
        }
        if (type instanceof graphql_1.GraphQLScalarType && this.decimalTypes[type.name]) {
            const decimalType = this.decimalTypes[type.name];
            return { name: 'decimal', options: [decimalType.p, decimalType.d] };
        }
        if (type instanceof graphql_1.GraphQLList) {
            return { name: 'json' };
        }
        throw new Error(`sql type for ${type} not support`);
    }
}
exports.GqlEntityController = GqlEntityController;
