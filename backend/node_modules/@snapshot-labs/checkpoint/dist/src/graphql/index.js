"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckpointsGraphQLObject = exports.MetadataGraphQLObject = exports.createGetLoader = void 0;
const express_graphql_1 = require("express-graphql");
const graphql_1 = require("graphql");
const dataloader_1 = __importDefault(require("dataloader"));
const database_1 = require("../utils/database");
/**
 * Creates getLoader function that will return existing, or create a new dataloader
 * for specific entity.
 * createGetLoader should be called per-request so each request has its own caching
 * and batching.
 */
const createGetLoader = (context) => {
    const loaders = {};
    return (name, field = 'id') => {
        const key = `${name}-${field}`;
        if (!loaders[key]) {
            loaders[key] = new dataloader_1.default(async (ids) => {
                const query = context.knex
                    .select('*')
                    .from((0, database_1.getTableName)(name))
                    .whereIn(field, ids);
                context.log.debug({ sql: query.toQuery(), ids }, 'executing batched query');
                const results = await query;
                const resultsMap = results.reduce((acc, result) => {
                    if (!acc[result[field]])
                        acc[result[field]] = [];
                    acc[result[field]].push(result);
                    return acc;
                }, {});
                return ids.map((id) => resultsMap[id] || []);
            });
        }
        return loaders[key];
    };
};
exports.createGetLoader = createGetLoader;
/**
 * Creates an graphql http handler for the query passed a parameters.
 * Returned middleware can be used with express.
 */
function get(schema, context, sampleQuery) {
    return (0, express_graphql_1.graphqlHTTP)(() => ({
        schema,
        context: {
            ...context,
            getLoader: (0, exports.createGetLoader)(context)
        },
        graphiql: {
            defaultQuery: sampleQuery
        }
    }));
}
exports.default = get;
/**
 * This objects name and field maps to the values of the _metadata
 * database store
 *
 */
exports.MetadataGraphQLObject = new graphql_1.GraphQLObjectType({
    name: '_Metadata',
    description: 'Core metadata values used internally by Checkpoint',
    fields: {
        id: { type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLID), description: 'example: last_indexed_block' },
        value: { type: graphql_1.GraphQLString }
    }
});
/**
 * This objects name and field maps to the values of the _checkpoints
 * database store. And is used to generate entity queries for graphql
 *
 */
exports.CheckpointsGraphQLObject = new graphql_1.GraphQLObjectType({
    name: '_Checkpoint',
    description: 'Contract and Block where its event is found.',
    fields: {
        id: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLID),
            description: 'id computed as last 5 bytes of sha256(contract+block)'
        },
        block_number: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLInt)
        },
        contract_address: {
            type: new graphql_1.GraphQLNonNull(graphql_1.GraphQLString)
        }
    }
});
